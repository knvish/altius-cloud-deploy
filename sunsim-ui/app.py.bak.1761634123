import os
import requests
import pandas as pd
import streamlit as st
import numpy as np
import matplotlib.pyplot as plt

st.set_page_config(page_title="SunSim Suite â€” Pro (IEC)", page_icon="ðŸŒž", layout="wide")

API_URL = os.getenv("API_URL", "http://api:8000")
PUBLIC_API_BASE = os.getenv("PUBLIC_API_BASE", "")

def api(path, method="GET", json=None):
    url = f"{API_URL}{path}"
    r = requests.request(method, url, json=json, timeout=15)
    if not (200 <= r.status_code < 300):
        try:
            err = r.json()
        except Exception:
            err = {"error": r.text}
        import streamlit as st  # safe in this scope
        st.error(f"API error {r.status_code}: {err}")
        st.stop()
    return r.json()

st.title("ðŸŒž SunSim Suite â€” Pro (IEC)")
st.caption("Calibration â€¢ History â€¢ IEC Spectral/Uniformity/Stability")

tab_sim, tab_hist, tab_health, tab_iec = st.tabs(["Simulator", "History", "Health", "IEC Test"])

# ---------------- SIMULATOR ----------------
with tab_sim:
    st.subheader("LED currents (mA)")
    col1, col2, col3 = st.columns(3)
    with col1:
        r = st.slider("Red", 0, 1000, 170, 10)
    with col2:
        g = st.slider("Green", 0, 1000, 400, 10)
    with col3:
        b = st.slider("Blue", 0, 1000, 400, 10)

    if st.button("Simulate", use_container_width=True):
        data = api("/simulate", method="POST", json={"red": r, "green": g, "blue": b})
        st.success(f"Irradiance: {data['irradiance_wm2']:.1f} W/mÂ²  Â· run_id={data['run_id']}")

    with st.expander("Calibration"):
        cal = api("/calibrate")
        st.write("Active coefficients (W/mÂ² per mA):", cal)
        rc = st.number_input("red_coeff", value=float(cal["red_coeff"]), step=0.01, format="%.4f")
        gc = st.number_input("green_coeff", value=float(cal["green_coeff"]), step=0.01, format="%.4f")
        bc = st.number_input("blue_coeff", value=float(cal["blue_coeff"]), step=0.01, format="%.4f")
        bias = st.number_input("bias", value=float(cal["bias"]), step=0.1, format="%.2f")
        note = st.text_input("note", value="manual update")
        if st.button("Update calibration"):
            api("/calibrate", method="POST", json={"red_coeff": rc, "green_coeff": gc, "blue_coeff": bc, "bias": bias, "note": note})
            st.success("Calibration updated.")

# ---------------- HISTORY ----------------
with tab_hist:
    st.subheader("Recent runs")
    items = api("/runs?limit=200")["items"]
    if items:
        df = pd.DataFrame(items)
        st.dataframe(df, use_container_width=True)
        st.caption("Persisted in Postgres; exported via /runs.")
    else:
        st.info("No runs yet. Simulate above.")

# ---------------- HEALTH ----------------
with tab_health:
    st.subheader("Health")
    h = api("/health")
    st.write(h)
    if PUBLIC_API_BASE:
        st.caption(f"External API base (LAN/Tailnet): {PUBLIC_API_BASE}")

# ---------------- IEC TESTS ----------------
with tab_iec:
    st.header("IEC Test â€” Spectral, Uniformity, Stability")
    st.write(
        """
This module helps you visualize **IEC 60904-9** metrics:
- **Spectral Match** vs AM1.5G (6 bins: 300â€“1200 nm) with ratio bands for A+/A/B/C  
- **Spatial Non-uniformity** heatmap and **S** (%)  
- **Temporal Instability** time series with **STI/LTI** (%)
"""
    )

    # --- Spectral (bins) ---
    st.subheader("1) Spectral Match (CSV: wavelength_nm,E)")
    spec_file = st.file_uploader("Upload spectrum CSV", type=["csv"], key="spec_csv")
    if spec_file is not None:
        df = pd.read_csv(spec_file)
        if {"wavelength_nm","E"}.issubset(df.columns):
            wl = df["wavelength_nm"].to_numpy()
            E = df["E"].to_numpy()
            res = api("/iec/spectral", method="POST", json={"wavelength_nm": wl.tolist(), "E": E.tolist()})
            if res.get("ok"):
                fr = np.array(res["bin_fractions"])
                am = np.array(res["am15g_bin_fractions"])
                ratio = np.array(res["ratio"])
                edges = np.array(res["bin_edges_nm"])

                st.success(f"Spectral Class (bins): {res['class']}")

                # Measured vs AM1.5G overlay (bin-step)
                show_am = st.checkbox("Show AM1.5G overlay", value=True)

                fig1 = plt.figure()
                E_norm = E / np.maximum(np.max(E), 1e-9)
                plt.plot(wl, E_norm, label="Measured (normalized)")

                if show_am:
                    am_wl, am_y = [], []
                    for i in range(len(edges) - 1):
                        lo, hi = edges[i], edges[i+1]
                        width = max(1e-9, hi - lo)
                        density = am[i] / width
                        am_wl.extend([lo, hi])
                        am_y.extend([density, density])
                    am_y = np.array(am_y, dtype=float)
                    am_y_norm = am_y / np.maximum(am_y.max(), 1e-9)
                    plt.plot(am_wl, am_y_norm, linestyle="--", label="AM1.5G (bin-step, normalized)")
                    for x in edges:
                        plt.axvline(x=x, linestyle=":", linewidth=0.8)

                plt.title("Measured Spectrum vs AM1.5G (normalized)")
                plt.xlabel("Wavelength (nm)")
                plt.ylabel("Relative")
                plt.legend()
                st.pyplot(fig1)

                # Bin comparison
                fig2 = plt.figure()
                x = np.arange(len(fr)); width = 0.35
                plt.bar(x - width/2, am, width, label="AM1.5G")
                plt.bar(x + width/2, fr, width, label="Measured")
                plt.xticks(x, [f"{int(edges[i])}-{int(edges[i+1])}" for i in range(len(edges)-1)])
                plt.ylabel("Fraction of total")
                plt.title("Bin Fractions (AM1.5G vs Measured)")
                plt.legend()
                st.pyplot(fig2)

                # Ratios vs class bands
                bands = {"A+": (0.875,1.125), "A":(0.75,1.25), "B":(0.60,1.40), "C":(0.40,2.00)}
                fig3 = plt.figure()
                x = np.arange(len(ratio))
                plt.plot(x, ratio, marker="o")
                for cls,(lo,hi) in bands.items():
                    plt.hlines([lo,hi], x[0]-0.5, x[-1]+0.5, linestyles="dashed")
                plt.xticks(x, [f"{int(edges[i])}-{int(edges[i+1])}" for i in range(len(edges)-1)])
                plt.ylabel("Measured / AM1.5G")
                plt.title("Bin Ratios vs Class Bands")
                st.pyplot(fig3)
            else:
                st.error(res.get("error","Unable to compute spectral match."))
        else:
            st.error("CSV must have columns: wavelength_nm,E")

    # --- Uniformity ---
    st.subheader("2) Spatial Uniformity (CSV grid, no header)")
    grid_file = st.file_uploader("Upload uniformity grid", type=["csv"], key="grid_csv")
    if grid_file is not None:
        gdf = pd.read_csv(grid_file, header=None)
        grid = gdf.values.tolist()
        res = api("/iec/uniformity", method="POST", json={"grid": grid})
        if res.get("ok"):
            S = res["S"]; cls = res["class"]
            st.success(f"Non-uniformity S = {S*100:.2f}% â†’ Class {cls}")
            fig = plt.figure()
            plt.imshow(gdf.values, aspect="equal")
            plt.colorbar(label="Irradiance")
            plt.title("Uniformity Heatmap")
            st.pyplot(fig)
            st.caption("S = (Imax âˆ’ Imin) / (Imax + Imin). Lower is better.")
        else:
            st.error("Could not compute uniformity.")

    # --- Stability ---
    st.subheader("3) Temporal Instability (single-column CSV)")
    colA,colB,colC = st.columns(3)
    sample_hz = colA.number_input("Sample rate (Hz)", 1.0, 5000.0, 100.0, 1.0)
    sti_s = colB.number_input("STI window (s)", 0.1, 10.0, 1.0, 0.1)
    lti_s = colC.number_input("LTI window (s)", 5.0, 600.0, 60.0, 5.0)
    ts_file = st.file_uploader("Upload time-series CSV", type=["csv"], key="ts_csv")
    if ts_file is not None:
        ts = pd.read_csv(ts_file, header=None)[0].astype(float).to_numpy()
        res = api("/iec/stability", method="POST", json={
            "irradiance": ts.tolist(), "sample_hz": sample_hz, "sti_window_s": sti_s, "lti_window_s": lti_s
        })
        if res.get("ok", True):
            st.success(f"STI â‰ˆ {res['sti_pct']:.2f}% (class {res['class_sti']}), LTI â‰ˆ {res['lti_pct']:.2f}% (class {res['class_lti']})")
            fig = plt.figure()
            plt.plot(ts)
            plt.title("Irradiance vs Time"); plt.xlabel("Sample"); plt.ylabel("Irradiance")
            st.pyplot(fig)
        else:
            st.error("Could not compute stability metrics.")

    # --- AM1.5G full-spectrum comparison (your request) ---
    st.subheader("4) AM1.5G Reference Spectrum Comparison")
    st.caption("Upload ASTM G-173 CSV (must include columns: wavelength_nm, AM1.5G)")

    ref_csv = st.file_uploader("Upload ASTM G-173 reference CSV", type=["csv"], key="ref_am15g")
    meas_csv = st.file_uploader("Upload your measured spectrum CSV (wavelength_nm,E)", type=["csv"], key="meas_am15g")

    ref_range = st.selectbox("Plot range (nm)", ["300â€“1200", "300â€“4000"], index=0)
    norm = st.checkbox("Normalize spectra", value=True)

    if ref_csv is not None:
        refdf = pd.read_csv(ref_csv)
        if {"wavelength_nm", "AM1.5G"}.issubset(refdf.columns):
            x = refdf["wavelength_nm"].astype(float).to_numpy()
            y = refdf["AM1.5G"].astype(float).to_numpy()

            lo, hi = (300, 1200) if ref_range == "300â€“1200" else (300, 4000)
            m = (x >= lo) & (x <= hi)
            x, y = x[m], y[m]

            if norm:
                y = y / np.maximum(np.max(y), 1e-9)

            fig = plt.figure()
            plt.plot(x, y, label="AM1.5G (ASTM G-173)", linewidth=2.2)

            if meas_csv is not None:
                mdf = pd.read_csv(meas_csv)
                if {"wavelength_nm", "E"}.issubset(mdf.columns):
                    xm = mdf["wavelength_nm"].astype(float).to_numpy()
                    ym = mdf["E"].astype(float).to_numpy()
                    mm = (xm >= lo) & (xm <= hi)
                    xm, ym = xm[mm], ym[mm]
                    if norm:
                        ym = ym / np.maximum(np.max(ym), 1e-9)
                    plt.plot(xm, ym, label="Measured", linewidth=1.8, color="red", alpha=0.9)
                else:
                    st.warning("Measured CSV must have columns: wavelength_nm,E")

            plt.xlim(lo, hi)
            plt.xlabel("Wavelength (nm)")
            plt.ylabel("Spectral Irradiance (W mâ»Â² nmâ»Â¹)" if not norm else "Normalized Irradiance")
            plt.title("AM1.5G Reference vs Measured Spectrum")
            plt.legend(frameon=True, framealpha=0.9, loc="upper right")
            plt.grid(True, alpha=0.3)
            st.pyplot(fig)
        else:
            st.error("CSV must contain columns: wavelength_nm and AM1.5G")
    else:
        st.info("Upload the ASTM G-173 file to plot the AM1.5G reference curve.")
