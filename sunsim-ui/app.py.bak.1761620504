import os, requests, pandas as pd, streamlit as st
import numpy as np
import matplotlib.pyplot as plt

st.set_page_config(page_title="SunSim Suite â€” Pro (IEC)", page_icon="ðŸŒž", layout="wide")

API_URL = os.getenv("API_URL", "http://api:8000")
PUBLIC_API_BASE = os.getenv("PUBLIC_API_BASE", "")

def api(path, method="GET", json=None):
    url = f"{API_URL}{path}"
    r = requests.request(method, url, json=json, timeout=15)
    if not (200 <= r.status_code < 300):
        try:
            err = r.json()
        except Exception:
            err = {"error": r.text}
        st.error(f"API error {r.status_code}: {err}")
        st.stop()
    return r.json()

st.title("ðŸŒž SunSim Suite â€” Pro (IEC)")
st.caption("Calibration â€¢ History â€¢ IEC Spectral/Uniformity/Stability")

tab_sim, tab_hist, tab_health, tab_iec = st.tabs(["Simulator", "History", "Health", "IEC Test"])

with tab_sim:
    st.subheader("LED currents (mA)")
    col1, col2, col3 = st.columns(3)
    with col1:
        r = st.slider("Red", 0, 1000, 170, 10)
    with col2:
        g = st.slider("Green", 0, 1000, 400, 10)
    with col3:
        b = st.slider("Blue", 0, 1000, 400, 10)

    if st.button("Simulate", use_container_width=True):
        data = api("/simulate", method="POST", json={"red": r, "green": g, "blue": b})
        st.success(f"Irradiance: {data['irradiance_wm2']:.1f} W/mÂ²  Â· run_id={data['run_id']}")

    with st.expander("Calibration"):
        cal = api("/calibrate")
        st.write("Active coefficients (W/mÂ² per mA):", cal)
        rc = st.number_input("red_coeff", value=float(cal["red_coeff"]), step=0.01, format="%.4f")
        gc = st.number_input("green_coeff", value=float(cal["green_coeff"]), step=0.01, format="%.4f")
        bc = st.number_input("blue_coeff", value=float(cal["blue_coeff"]), step=0.01, format="%.4f")
        bias = st.number_input("bias", value=float(cal["bias"]), step=0.1, format="%.2f")
        note = st.text_input("note", value="manual update")
        if st.button("Update calibration"):
            api("/calibrate", method="POST", json={"red_coeff": rc, "green_coeff": gc, "blue_coeff": bc, "bias": bias, "note": note})
            st.success("Calibration updated.")

with tab_hist:
    st.subheader("Recent runs")
    items = api("/runs?limit=200")["items"]
    if items:
        df = pd.DataFrame(items)
        st.dataframe(df, use_container_width=True)
        st.caption("Persisted in Postgres; exported via /runs.")
    else:
        st.info("No runs yet. Simulate above.")

with tab_health:
    st.subheader("Health")
    h = api("/health")
    st.write(h)
    if PUBLIC_API_BASE:
        st.caption(f"External API base (LAN/Tailnet): {PUBLIC_API_BASE}")

with tab_iec:
    st.header("IEC Test â€” Spectral, Uniformity, Stability")
    st.write("""
This module helps you visualize **IEC 60904-9** metrics:
- **Spectral Match** vs AM1.5G (6 bins: 300â€“1200 nm) with ratio bands for A+/A/B/C  
- **Spatial Non-uniformity** heatmap and **S** (%)  
- **Temporal Instability** time series with **STI/LTI** (%)
""")

    # --- Spectral ---
    st.subheader("1) Spectral Match (CSV: wavelength_nm,E)")
    spec_file = st.file_uploader("Upload spectrum CSV", type=["csv"], key="spec_csv")
    if spec_file is not None:
        df = pd.read_csv(spec_file)
        if set(df.columns) >= {"wavelength_nm","E"}:
            wl = df["wavelength_nm"].to_numpy()
            E = df["E"].to_numpy()
            res = api("/iec/spectral", method="POST", json={"wavelength_nm": wl.tolist(), "E": E.tolist()})
            if res.get("ok"):
                fr = np.array(res["bin_fractions"])
                am = np.array(res["am15g_bin_fractions"])
                ratio = np.array(res["ratio"])
                edges = np.array(res["bin_edges_nm"])

                st.success(f"Spectral Class (bins): {res['class']}")

                colA, colB = st.columns(2)
                with colA:
                    fig1 = plt.figure()
                    plt.plot(wl, E/np.maximum(np.max(E),1e-9))
                    plt.title("Measured Spectrum (normalized)")
                    plt.xlabel("Wavelength (nm)"); plt.ylabel("Relative")
                    st.pyplot(fig1)

                with colB:
                    fig2 = plt.figure()
                    x = np.arange(len(fr)); width = 0.35
                    plt.bar(x - width/2, am, width, label="AM1.5G")
                    plt.bar(x + width/2, fr, width, label="Measured")
                    plt.xticks(x, [f"{int(edges[i])}-{int(edges[i+1])}" for i in range(len(edges)-1)])
                    plt.ylabel("Fraction of total")
                    plt.title("Bin Fractions (AM1.5G vs Measured)")
                    plt.legend()
                    st.pyplot(fig2)

                fig3 = plt.figure()
                x = np.arange(len(ratio))
                plt.plot(x, ratio, marker="o")
                bands = {"A+": (0.875,1.125), "A":(0.75,1.25), "B":(0.60,1.40), "C":(0.40,2.00)}
                for cls,(lo,hi) in bands.items():
                    plt.hlines([lo,hi], x[0]-0.5, x[-1]+0.5, linestyles="dashed")
                plt.xticks(x, [f"{int(edges[i])}-{int(edges[i+1])}" for i in range(len(edges)-1)])
                plt.ylabel("Measured / AM1.5G")
                plt.title("Bin Ratios vs Class Bands")
                st.pyplot(fig3)

                with st.expander("Interpretation"):
                    st.markdown("""
- Each point = your bin energy Ã· AM1.5G bin energy.  
- To achieve a class, **all** points must sit within that band.  
- Correct out-of-band bins with driver trims, spectral filters, or extra channels.
""")
            else:
                st.error(res.get("error","Unable to compute spectral match."))
        else:
            st.error("CSV must have columns: wavelength_nm,E")

    # --- Uniformity ---
    st.subheader("2) Spatial Uniformity (CSV grid, no header)")
    grid_file = st.file_uploader("Upload uniformity grid", type=["csv"], key="grid_csv")
    if grid_file is not None:
        gdf = pd.read_csv(grid_file, header=None)
        grid = gdf.values.tolist()
        res = api("/iec/uniformity", method="POST", json={"grid": grid})
        if res.get("ok"):
            S = res["S"]; cls = res["class"]
            st.success(f"Non-uniformity S = {S*100:.2f}% â†’ Class {cls}")
            fig = plt.figure()
            plt.imshow(gdf.values, aspect="equal")
            plt.colorbar(label="Irradiance")
            plt.title("Uniformity Heatmap")
            st.pyplot(fig)
            st.caption("S = (Imax âˆ’ Imin) / (Imax + Imin). Lower is better.")
        else:
            st.error("Could not compute uniformity.")

    # --- Stability ---
    st.subheader("3) Temporal Instability (single-column CSV)")
    colA,colB,colC = st.columns(3)
    sample_hz = colA.number_input("Sample rate (Hz)", 1.0, 5000.0, 100.0, 1.0)
    sti_s = colB.number_input("STI window (s)", 0.1, 10.0, 1.0, 0.1)
    lti_s = colC.number_input("LTI window (s)", 5.0, 600.0, 60.0, 5.0)
    ts_file = st.file_uploader("Upload time-series CSV", type=["csv"], key="ts_csv")
    if ts_file is not None:
        ts = pd.read_csv(ts_file, header=None)[0].astype(float).to_numpy()
        res = api("/iec/stability", method="POST", json={
            "irradiance": ts.tolist(), "sample_hz": sample_hz, "sti_window_s": sti_s, "lti_window_s": lti_s
        })
        if res.get("ok", True):
            st.success(f"STI â‰ˆ {res['sti_pct']:.2f}% (class {res['class_sti']}), LTI â‰ˆ {res['lti_pct']:.2f}% (class {res['class_lti']})")
            fig = plt.figure()
            plt.plot(ts)
            plt.title("Irradiance vs Time"); plt.xlabel("Sample"); plt.ylabel("Irradiance")
            st.pyplot(fig)
        else:
            st.error("Could not compute stability metrics.")
